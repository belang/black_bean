# 指令设计

以硬件每个执行动作为基本单位进行设计。
在一拍内，完成取指、译码、发射、执行、写回的操作。
不管一拍还是多拍完成，整个流水级要完整，则数据通道要足够。
很多功能需要多个操作数，功能结果也可能是多个操作数，
要一拍完成，则数据通道要多条。
同时，寄存器只能一次读一条数据，或写一条数据，
要一拍完成，则读写要分离，读写数据通道都只有一条。

一条加法指令可以拆分成：取数1、取数2、计算、写结果，四个步骤。
要实现一拍或流水，需要两个读数通道，一个写通道。
还有一种选择是拆分指令。四个步骤分成四个指令，顺序执行。
单动作指令设计灵活，更能体现硬件信号传输过程，所以以单动作指令进行设计。

硬件基本操作是读和写。操作内容是地址（端口）和数据。操作对象有内存、寄存器、运算器、外设。
由此设计单动作指令格式为：读、写，对象，地址（立即数）。
无论读写，默认数据在对应的数据总线中。
每一对读写动作完成一次数据搬运。因为读写之间的数据缓存在数据总线上，
所以读写操作必须成对出现，而且连续读写。如果不连续，则需要缓存。

## 单动作指令
每个单动作指令由两行指令，共8*2=16个字节构成。
其结构如下：

前8位是器件名称，后8位是端口（地址）

### 器件划分

| 名称       | 编码 | 简称 |                |
|------------|------|------|----------------|
| 指令寄存器 | 0001 | 令寄 |                |
| 数据寄存器 | 0010 | 数寄 |                |
| 运算器     | 0011 | 运算 |                |
| 外设       | 0100 | 外   |                |
| 控制       | 0101 | 控   |                |
| 缓存       | 0111 | 缓   | 用来设置立即数 |

#### 外设

| 名称         | 编码 | 说明                               | 简称     |
|--------------|------|------------------------------------|----------|
| 内存指令     | 0001 | 向内存控制器发送指令，控制内存读写 |          |
| 内存数据读   | 0010 | 读取内存控制器缓存的数据，一次一行 |          |
| 内存数据写   | 0011 | 向内存控制器缓存写入数据，一次一行 |          |
| 内存数据有效 |      |                                    | 内存数备 |
|              |      |                                    |          |

#### 运算

| 名称     | 编码 | 说明 | 简称 |
|----------|------|------|------|
| 被加数   | 0001 | 写   | 基   |
| 加数     | 0010 | 写   | 累   |
| 加结果   | 0011 | 读   | 和   |
| 加进位   | 0100 | 读   | 进   |
| 被比较数 | 0110 | 写   | 尺   |
| 比较数   | 0101 | 写   | 量   |
| 比较结果 | 0111 | 读   | 较   |

#### 控制

| 名称     | 编码 | 说明                       | 简称 |
|----------|------|----------------------------|------|
| 工作     | 0010 | 空，切换到工作寄存器       |      |
| 大于跳   | 0011 | 写，输入的是比较结果       |      |
| 小于跳   | 0100 | 写                         |      |
| 等于跳   | 0101 | 写                         |      |
| 不等于跳 | 0101 | 写                         | 异跳 |
| 直接跳   | 0110 | 写                         | 同跳 |
| 跳转地址 | 0110 | 写                         | 跳达 |
| 等待     | 0111 | 写，等待某个值为高（有效） |      |
| 停       | 1000 | 空，代表停止               |      |

## 组合动作
加载数据动作由跳转、计数、读、写、等待构成。

| 动作 | 运算   | 读       | 缓存   | 写     |                  |
| 指令 | 源器件 | 源地址   | 终器件 | 终地址 |                  |
|------|--------|----------|--------|--------|------------------|
| 加   | *      | *        | 运算   | 基     |                  |
| T16  | *      | *        | 运算   | 累     |                  |
|      | 运算   | 加结果   | *      | *      |                  |
|      | 运算   | 加进位   | *      | *      |                  |
| 比较 | *      | *        | 运算   | 尺     |                  |
|      | *      | *        | 运算   | 量     |                  |
|      | 运算   | 较       | *      | *      |                  |
| 跳转 | *      | *        | 控制   | *跳    | 判断条件         |
|      | *      | *        | 控制   | 跳达   | 跳转地址         |
| 加载 | 缓存   | 00000001 | 运算   | 尺     |                  |
|      | 缓存   | 8'h9     | 数寄   | 0      |                  |
|      | 外设   | 内存数备 | 运算   | 量     |                  |
|      | 运算   | 较       | 控制   | 异跳   |                  |
|      | 数寄   | 0        | 控制   | 跳达   | ？先写入跳转地址 |
|      | 运算   | 较       | *      | *      |                  |

# 指令集

模块的读写都是与数据总线进行交互。

指令分类：状态控制、数据处理、数据读写、逻辑判断

| 符       | 操作数           | 例           | 说明                                   |
|----------|------------------|--------------|----------------------------------------|
|          | 状态控制         |              |                                        |
|----------|------------------|--------------|----------------------------------------|
| 复位     |                  |              | 复位系统                               |
| 停止     |                  |              | 停止                                   |
| 等待     | IR               |              | 等待之前某条指令完成                   |
|----------|------------------|--------------|----------------------------------------|
|          | 逻辑判断         |              |                                        |
|----------|------------------|--------------|----------------------------------------|
| 跳转     | 址               | 跳0H09       | 下一指令地址为寄令地址为0H09行         |
| 判断跳转 | 结果 址          | 真跳 R1 0H09 | 如果R1非零，则下一指令地址为寄令0H09行 |
|----------|------------------|--------------|----------------------------------------|
|          | 数据读写         |              |                                        |
|----------|------------------|--------------|----------------------------------------|
| 读数     | 源址，靶址，行   | 读数，       | 读是从内存读，写是向内存写。           |
| 读令     | \/               | 0H00，       | 读取内存中0H00行向后的16行数据         |
| 存数     | 源址，靶址，行   | 0H01，       | 到寄令的0H01行及以后16行               |
| 存令     | \/               | 0H0F。       |                                        |
| 设       | 寄，数（寄、址） | 设R1，100    | 设置R1的值为100                        |
| 设       | 寄，寄           | 设R1，R2     | 设置R1的值为R2的值                     |
| 设       | 寄，址           | 设R1，0Hf1   | 设置R1的值为内存地址为0Hf1的数据       |
|----------|------------------|--------------|----------------------------------------|
|          | 数据处理         |              |                                        |
|----------|------------------|--------------|----------------------------------------|
| 加       | Reg, Reg, Reg    | 加R1，R2，R3 | 将R1、R2的数据相加，结果存在R3         |
| 减       | Reg, Reg, Reg    |              | R1-R2，结果存在R3                      |
| 大于     | Reg, Reg, Reg    | 比R1，R2，R3 | R1>R2则为1，写入R3                     |
| 小于     | Reg, Reg, Reg    | 比R1，R2，R3 | R1<R2则为1，写入R3                     |
| 等于     | Reg, Reg, Reg    | 比R1，R2，R3 | R1=R2则为1，写入R3                     |
|          |                  |              |                                        |

# 译码
I : input; O : output; M : inner

| 符   | 码       | code  |
|------|----------|-------|
| 跳   | 00000010 | JUMP  |
| 停   | 00001110 | STOP  |
| 载   | 10000000 | LOAD  |
| 卸   | 10000001 | STORE |
| 复   | 00001111 | RESET |
| 设数 | 00010000 | SET_D |
| 设寄 | 00010001 | SET_R |
| 设址 | 00010010 | SET_A |
| 加   | 00100000 | ADD   |
| 减   | 00100001 | SUB   |
| (x)  | 00100010 |       |
| (/)  | 00100011 |       |
| 大于 | 00101000 | LARGE |
| 小于 | 00101001 | SMALL |
| 等于 | 00101010 | EQUAL |
|      |          |       |

# 指令地址分配

| 地址 | 说明     |
|------|----------|
| 0000 | 系统控制 |
| 0001 | 内部存储 |
| 1000 | 外部存储 |
| 0010 | 运算     |

# 微指令

| 机器         | 目标     | 起源   | 说明                       |
|--------------|----------|--------|----------------------------|
| start        | 00000001 | 空     | 从IR中自动读取数据         |
| jump         | 00000010 | 地址   | 跳转到指令寄存器地址       |
| wait         | 00000011 | signal | 等待某信号有效             |
|--------------|----------|--------|----------------------------|
| mem_read     | 10000000 | addr   | 数据存储器到数据总线       |
| mem_write    | 10000001 | addr   | 数据总线到数据存储器       |
|--------------|----------|--------|----------------------------|
| ir_write     | 00010010 | addr   | 两拍写一条指令             |
| ir_read      | 00010011 | addr   | 两拍读一条指令             |
| dreg_write   | 00010100 | 写地址 | 数据寄存器写               |
| dreg_read    | 00010101 | 读地址 | 数据寄存器读               |
| cur_data     | 00010110 | 数据   | 将指令中的数据送入数据总线 |
|--------------|----------|--------|----------------------------|
| adder_a      | 00101000 | 空     | 加法器被加数写             |
| adder_b      | 00101001 | 空     | 加法器加数写               |
| adder_result | 00101010 | 空     | 加法器和读                 |
| adder_carry  | 00101011 | 空     | 加法器进位读               |
| adder_clear  | 00101100 | 空     | 加法器进位清空             |
| compare_a    | 00101101 | 空     | 比较器                     |
| compare_b    | 00101110 | 空     | 比较器                     |
| compare_r    | 00101111 | 空     | 比较器结果（a>b)           |
| counter      | 00100001 | 数据   | 置计数器                   |
|--------------|----------|--------|----------------------------|
|              |          |        |                            |
| call         |          |        |                            |
| return       |          |        |                            |



## 跳转
在编译时，行号写入寄存器而不是用JUMP直接跳转。
因为，在加载时，行号才确定，而此时不适合动态修改指令。
因此，跳转指令后的地址是寄存器。

# 汇编示例
## 简单加法
156+38

{{{
stack1 1\5\6
stack2 3\8
stack3 addc
adda stack1
addb stack2
dreg4 stack3
}}}

考虑字符串结束标识。。。。

汇编
{{{
  R1 6
  R1 5
  R1 1
  R2 3
  R2 8
  R3 add R1 R2

机械指令::
  
  cur_data 6
  dreg_write 0
  cur_data 5
  dreg_write 1
  cur_data 1
  dreg_write 2
  cur_data 8
  dreg_write 3
  cur_data 3
  dreg_write 4
  dreg_read 0
  add_a
  dreg_read 3
  add_b
  add_r
  dreg_write 5
  dreg_read 1
  add_a
  dreg_read 4
  add_b
  add_r
  dreg_write 6
  dreg_read 2
  add_a
  data_bus_clear
  add_b
  add_r
  dreg_write 7
  add_i
  dreg_write 8
}}}
结果存在数据寄存器的8765四个地址中。

## 循环加法
从1加到100。

{{{
高级语言::

  y = 1
  for x in range(2,100):
    y += x

汇编::

  cur_data 1
  dreg_write 0

}}}

