= 指令集 =

模块的读写都是与数据总线进行交互。

| 符   | 操作数             | 例           | 说明                             |
|------|--------------------|--------------|----------------------------------|
| 跳   | 址                 | 跳0H09       | 下一指令地址为寄令地址为0H09行   |
| 停   | 无                 | 停           | 停止                             |
| 起   | 无                 | 起           | 复位系统                         |
| 读   | 靶，址，源，址，行 | 读寄令0H01， | 读取内存中0HF0行向后的16行数据   |
| \/   | \/                 | 内0HF0，0H0F | 到寄令的0H01行及以后16行         |
| 写   | 靶，址，源，址，行 | 写寄令0H01， | 写取内存中0HF0行向后的16行数据   |
| \/   | \/                 | 内0HF0，0H0F | 到寄令的0H01行及以后16行         |
| 加   | Reg, Reg, Reg      | 加R1，R2，R3 | 将R1、R2的数据相加，结果存在R3   |
| 减   | Reg, Reg, Reg      |              | R1-R2，结果存在R3                |
| 设   | 寄，数（寄、址）   | 设R1，100    | 设置R1的值为100                  |
| 设   | 寄，寄             | 设R1，R2     | 设置R1的值为R2的值               |
| 设   | 寄，址             | 设R1，0Hf1   | 设置R1的值为内存地址为0Hf1的数据 |
| 比大 | Reg, Reg, Reg      | 比R1，R2，R3 | R1>R2则为1，写入R3               |
| 比小 | Reg, Reg, Reg      | 比R1，R2，R3 | R1<R2则为1，写入R3               |
| 比大 | Reg, Reg, Reg      | 比R1，R2，R3 | R1=R2则为1，写入R3               |
|      |                    |              |                                  |

= 译码 =
I : input; O : output; M : inner

| 符   | 码       | 微                           |                                  |         |
|------|----------|------------------------------|----------------------------------|---------|
|      |          | 译码                         | 发射（数据送到总线）             | 运算    |
| 跳   | 00000010 | Id=jump,Oir=next,Mstate=jump | Id=DR_addr,Odata_bus=Id,Oir=jump | Id=null |
|      |          | 取指                         |                                  |         |
|      |          | Id=next_ir                   |                                  |         |
| 停   | 00001110 | stop                         |                                  |         |
| 读   | 10000000 |                              |                                  |         |
| 写   | 10000001 |                              |                                  |         |
| 起   | 00001111 |                              |                                  |         |
| 设数 | 00010000 |                              |                                  |         |
| 设寄 | 00010001 |                              |                                  |         |
| 设址 | 00010010 |                              |                                  |         |
| 加   | 00100000 |                              |                                  |         |
| 减   | 00100001 |                              |                                  |         |
| (x)  | 00100010 |                              |                                  |         |
| (/)  | 00100011 |                              |                                  |         |
| 比大 | 00101000 |                              |                                  |         |
| 比小 | 00101001 |                              |                                  |         |
| 比大 | 00101010 |                              |                                  |         |
|      |          |                              |                                  |         |

= 指令地址分配 =

| 地址 | 说明     |
|------|----------|
| 0000 | 系统控制 |
| 0001 | 内部存储 |
| 1000 | 外部存储 |
| 0010 | 运算     |

| 机器         | 目标     | 起源   | 说明                       |
|--------------|----------|--------|----------------------------|
| start        | 00000001 | 空     | 从IR中自动读取数据         |
| jump         | 00000010 | 地址   | 跳转到指令寄存器地址       |
|--------------|----------|--------|----------------------------|
| mem_read     | 10000000 | addr   | 数据存储器到数据总线       |
| mem_write    | 10000001 | addr   | 数据总线到数据存储器       |
|--------------|----------|--------|----------------------------|
| ir_write     | 00010010 | addr   | 两拍写一条指令             |
| ir_read      | 00010011 | addr   | 两拍读一条指令             |
| dreg_write   | 00010100 | 写地址 | 数据寄存器写               |
| dreg_read    | 00010101 | 读地址 | 数据寄存器读               |
| cur_data     | 00010110 | 数据   | 将指令中的数据送入数据总线 |
|--------------|----------|--------|----------------------------|
| adder_a      | 00101000 | 空     | 加法器被加数写             |
| adder_b      | 00101001 | 空     | 加法器加数写               |
| adder_result | 00101010 | 空     | 加法器和读                 |
| adder_carry  | 00101011 | 空     | 加法器进位读               |
| adder_clear  | 00101100 | 空     | 加法器进位清空             |
| compare_a    | 00101101 | 空     | 比较器                     |
| compare_b    | 00101110 | 空     | 比较器                     |
| compare_r    | 00101111 | 空     | 比较器结果（a>b)           |
|              |          |        |                            |


== 跳转 ==
在编译时，行号写入寄存器而不是用JUMP直接跳转。
因为，在加载时，行号才确定，而此时不适合动态修改指令。
因此，跳转指令后的地址是寄存器。

= 汇编示例 =
== 简单加法 ==
156+38

{{{
stack1 1\5\6
stack2 3\8
stack3 addc
adda stack1
addb stack2
dreg4 stack3
}}}

考虑字符串结束标识。。。。

汇编
{{{
  R1 6
  R1 5
  R1 1
  R2 3
  R2 8
  R3 add R1 R2

机械指令::
  
  cur_data 6
  dreg_write 0
  cur_data 5
  dreg_write 1
  cur_data 1
  dreg_write 2
  cur_data 8
  dreg_write 3
  cur_data 3
  dreg_write 4
  dreg_read 0
  add_a
  dreg_read 3
  add_b
  add_r
  dreg_write 5
  dreg_read 1
  add_a
  dreg_read 4
  add_b
  add_r
  dreg_write 6
  dreg_read 2
  add_a
  data_bus_clear
  add_b
  add_r
  dreg_write 7
  add_i
  dreg_write 8
}}}
结果存在数据寄存器的8765四个地址中。

== 循环加法 ==
从1加到100。

{{{
高级语言::

  y = 1
  for x in range(2,100):
    y += x

汇编::

  cur_data 1
  dreg_write 0

}}}

