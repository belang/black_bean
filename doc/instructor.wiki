= 指令集 =

模块的读写都是与数据总线进行交互。

| 符   | 操作数           | 例             | 说明                                   |
|------|------------------|----------------|----------------------------------------|
| 停   |                  |                | 停止                                   |
| 复   |                  |                | 复位系统                               |
| 等   | IR               |                | 等待之前某条指令完成                   |
| 跳   | 址               | 跳0H09         | 下一指令地址为寄令地址为0H09行         |
| 载   | 源址，靶址，行   | 载内0HF0，     | 载卸总是存储器与指令寄存器之间的操作。 |
| \/   | \/               | 寄令0H01，0H0F | 读取内存中0HF0行向后的16行数据         |
| 卸   | 源址，靶址，行   | 卸内0HF0，     | 到寄令的0H01行及以后16行               |
| \/   | \/               | 寄令0H01，0H0F |                                        |
| 加   | Reg, Reg, Reg    | 加R1，R2，R3   | 将R1、R2的数据相加，结果存在R3         |
| 减   | Reg, Reg, Reg    |                | R1-R2，结果存在R3                      |
| 设   | 寄，数（寄、址） | 设R1，100      | 设置R1的值为100                        |
| 设   | 寄，寄           | 设R1，R2       | 设置R1的值为R2的值                     |
| 设   | 寄，址           | 设R1，0Hf1     | 设置R1的值为内存地址为0Hf1的数据       |
| 大于 | Reg, Reg, Reg    | 比R1，R2，R3   | R1>R2则为1，写入R3                     |
| 小于 | Reg, Reg, Reg    | 比R1，R2，R3   | R1<R2则为1，写入R3                     |
| 等于 | Reg, Reg, Reg    | 比R1，R2，R3   | R1=R2则为1，写入R3                     |
|      |                  |                |                                        |

= 译码 =
I : input; O : output; M : inner

| 符   | 码       | code  |
|------|----------|-------|
| 跳   | 00000010 | JUMP  |
| 停   | 00001110 | STOP  |
| 载   | 10000000 | LOAD  |
| 卸   | 10000001 | STORE |
| 复   | 00001111 | RESET |
| 设数 | 00010000 | SET_D |
| 设寄 | 00010001 | SET_R |
| 设址 | 00010010 | SET_A |
| 加   | 00100000 | ADD   |
| 减   | 00100001 | SUB   |
| (x)  | 00100010 |       |
| (/)  | 00100011 |       |
| 大于 | 00101000 | LARGE |
| 小于 | 00101001 | SMALL |
| 等于 | 00101010 | EQUAL |
|      |          |       |

= 指令地址分配 =

| 地址 | 说明     |
|------|----------|
| 0000 | 系统控制 |
| 0001 | 内部存储 |
| 1000 | 外部存储 |
| 0010 | 运算     |

| 机器         | 目标     | 起源   | 说明                       |
|--------------|----------|--------|----------------------------|
| start        | 00000001 | 空     | 从IR中自动读取数据         |
| jump         | 00000010 | 地址   | 跳转到指令寄存器地址       |
|--------------|----------|--------|----------------------------|
| mem_read     | 10000000 | addr   | 数据存储器到数据总线       |
| mem_write    | 10000001 | addr   | 数据总线到数据存储器       |
|--------------|----------|--------|----------------------------|
| ir_write     | 00010010 | addr   | 两拍写一条指令             |
| ir_read      | 00010011 | addr   | 两拍读一条指令             |
| dreg_write   | 00010100 | 写地址 | 数据寄存器写               |
| dreg_read    | 00010101 | 读地址 | 数据寄存器读               |
| cur_data     | 00010110 | 数据   | 将指令中的数据送入数据总线 |
|--------------|----------|--------|----------------------------|
| adder_a      | 00101000 | 空     | 加法器被加数写             |
| adder_b      | 00101001 | 空     | 加法器加数写               |
| adder_result | 00101010 | 空     | 加法器和读                 |
| adder_carry  | 00101011 | 空     | 加法器进位读               |
| adder_clear  | 00101100 | 空     | 加法器进位清空             |
| compare_a    | 00101101 | 空     | 比较器                     |
| compare_b    | 00101110 | 空     | 比较器                     |
| compare_r    | 00101111 | 空     | 比较器结果（a>b)           |
|              |          |        |                            |


== 跳转 ==
在编译时，行号写入寄存器而不是用JUMP直接跳转。
因为，在加载时，行号才确定，而此时不适合动态修改指令。
因此，跳转指令后的地址是寄存器。

= 汇编示例 =
== 简单加法 ==
156+38

{{{
stack1 1\5\6
stack2 3\8
stack3 addc
adda stack1
addb stack2
dreg4 stack3
}}}

考虑字符串结束标识。。。。

汇编
{{{
  R1 6
  R1 5
  R1 1
  R2 3
  R2 8
  R3 add R1 R2

机械指令::
  
  cur_data 6
  dreg_write 0
  cur_data 5
  dreg_write 1
  cur_data 1
  dreg_write 2
  cur_data 8
  dreg_write 3
  cur_data 3
  dreg_write 4
  dreg_read 0
  add_a
  dreg_read 3
  add_b
  add_r
  dreg_write 5
  dreg_read 1
  add_a
  dreg_read 4
  add_b
  add_r
  dreg_write 6
  dreg_read 2
  add_a
  data_bus_clear
  add_b
  add_r
  dreg_write 7
  add_i
  dreg_write 8
}}}
结果存在数据寄存器的8765四个地址中。

== 循环加法 ==
从1加到100。

{{{
高级语言::

  y = 1
  for x in range(2,100):
    y += x

汇编::

  cur_data 1
  dreg_write 0

}}}

